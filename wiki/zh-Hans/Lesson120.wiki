= Guzz入门教程 =

在本教程中，我们将手把手的演示如何使用guzz，编写一个可以并行使用5台甚至更多数据库的留言板系统。

您可以一边看一边跟着做。在实际的教程做，只需要1台数据库用来模拟。


本教程将教会你：如何创建guzz项目，如何用guzz添加数据库记录，如何实现读写分离，如何进行多数据库之间分表、切表、分布式切表等，并对“服务”有个概念。


= 教程目录大纲  =

<wiki:toc max_depth="2" />


= 什么是guzz？什么时候用？  =

guzz[ˈɡuzi]念做谷子。稻谷的谷，意为种子、谷物等。

guzz和hibernate，ibatis同属于数据持久层框架，在应用架构上用于代替hibernate或者ibatis。使用guzz后，传统的ssh（spring + struts + hibernate）程序就变成了ssg（spring + struts + guzz）。同时guzz也可以和hibernate/ibatis并存，同时使用。

guzz适合于大型系统使用，包括访问量较大的系统和数据量较大的系统。当你的程序需要同时使用多台数据库，或者存在大表需要分切成小表时，guzz是目前通用持久层框架中最好的选择。guzz提供了面向未来的配置化分表、多库、表分切、读写分离，以及多台数据库之间透明的分布式事务支持等特性，使得多数据库编程和普通编程一样简单，对开发者透明。

同时guzz提供一些服务定义，帮助团队从零开始创建云服务计算平台。如果您计划将多个系统间的通用计算（功能）做成服务，并且还没有动手，guzz service将是个很好的起步点。

guzz框架免费开源，项目地址：[http://code.google.com/p/guzz/]


= 准备开发环境  =

在本教程中，我们使用MyEclipse IDE做开发演示。留言板将运行在1台Mysql5.0 + 1台Tomcat6上。因此您只需要自己的开发机器就可以跟上。

当然，如果你有5台或者更多数据库，会更好。

虽然教程中只有1台数据库，但效果一样。你可以更清楚的看到，guzz使用多台数据库还是只用1台数据库，对开发者基本透明。


= 创建MessageBoard工程  =

我们基于 springIOC + springMVC + guzz 架构创建留言板，因此先从guzz网站下载提供的空工程 a empty sample project buildxxxxxxx.zip ：[http://code.google.com/p/guzz/downloads/list]

解压工程，并导入到Eclipse中（File -> Import -> General/Existing Projects into Workspace）。
 
这时工作区中多了一个名为“GuzzEmpty”的项目。选择项目，右键 -> Refactor -> Rename。输入MessageBoard，确定。

从 [http://code.google.com/p/guzz/downloads/list] 下载最新版的guzz发布包，如“guzz1.2.9 buildxxxxxx.zip”，解压文件，将最新的guzz.jar覆盖到刚刚创建的MessageBoard工程的 /WebRoot/WEB-INF/lib/ 下。

修改 /WebRoot/WEB-INF/ 下的 fms.properties 为 messageBoard.properties ，这个为我们的主配置文件。


= 配置工程，插入第1条留言 =

== 配置工程 ==

我们定义留言为Message，在src源代码目录下创建域对象example/business/Message.java：
{{{
package example.business;

import java.util.Date;

public class Message implements java.io.Serializable {
	
	private int id ;

	private String content ;
	
	private Date createdTime ;
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Date getCreatedTime() {
		return createdTime;
	}

	public void setCreatedTime(Date createdTime) {
		this.createdTime = createdTime;
	}
	
}
}}}

同时在 example/business/ 目录下创建域对象的映射文件 Message.hbm.xml：
{{{
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
	<class name="example.business.Message" table="tb_message">
		<id name="id" type="int" column="id">
			<generator class="native" />
		</id>
		<property name="content" type="string" column="content" />
		<property name="createdTime" type="datetime" column="createdTime" />
	</class>
</hibernate-mapping>
}}}

在映射文件中，留言存储在tb_message表中。tb_message用content字段存储留言内容。

启动并连上Mysql5.0，创建测试用数据库mb_main，并在其中创建表tb_message。sql语句如下：
{{{
create database mb_main default character set utf8 ;

use mb_main ;

create table tb_message(
	id int not null auto_increment primary key, 
	content text, 
	createdTime datetime
)engine=Innodb ;

}}}

好啦，现在需要配置数据库连接池，让mb_main数据库和MessageBoard工程对接上。

打开 /WebRoot/WEB-INF/guzz.xml 文件，选择源代码模式编辑。右键选择 /WebRoot/WEB-INF/messageBoard.properties -> Open With -> Properties File Editor（注意：不能用高级可视化编辑器打开），打开主配置文件。

修改guzz.xml：删除默认配置的3组数据库组中的updateDB和logDB；删除2个service服务；在business中增加Message域对象声明。修改后的guzz.xml为：
{{{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guzz-configs PUBLIC "-//GUZZ//DTD MAIN CONFIG//EN" "http://www.guzz.org/dtd/guzz.dtd">

<guzz-configs>
	
	<dialect class="org.guzz.dialect.Mysql5Dialect" />
	
	<tran>
		<dbgroup name="default" masterDBConfigName="masterDB" />
	</tran>
	
	<config-server>
		<server class="org.guzz.config.LocalFileConfigServer">
			<param name="resource" value="messageBoard.properties" />
		</server>
	</config-server>
	
	<!-- business starts -->
	<business dbgroup="default" name="message" file="classpath:example/business/Message.hbm.xml" />
	<!-- business ends -->

</guzz-configs>
}}}

在新的guzz.xml中，留言对象使用default数据库组，default数据库组的master数据库的配置组名称为“masterDB”，没有slave数据库。修改刚刚打开的messageBoard.properties，修改[masterDB]配置组的连接池，指向我们刚才创建的数据库mb_main。其他数据库组配置删除。新的messageBoard.properties内容如下：
{{{
#guzz app config file.
 
#master db
[masterDB]
guzz.identifer=defaultMasterDB1
guzz.IP=localhost
guzz.maxLoad=120
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_main?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60
 
#debug settings
[guzzDebug]
#runMode=debug/production
runMode=debug
#onError=halt/log/ignore
onError=halt
printSQL=true
printSQLParams=true
ignoreDemonThreadSQL=true
#print out how many nano-seconds a sql takes to execute.
measureTime=true
#only print out slow sqls that takes over xxx mill-seconds to execute. 0 means print out all.
onlySlowSQLInMillSeconds=0

############################### fundamental services #####################

}}}

打开 /WebRoot/WEB-INF/applicationContext.xml，删除bean:insertQueueService 。

部署工程到Tomcat6上，然后启动。如果没有错误，则配置已经成功。如果报错，请检查数据库是否给予了访问授权等。

停止tomcat6.

== 插入留言 ==

下面我们开始插入第一条留言。

在/WebRoot/下创建jsp文件：messagesList.jsp，用于显示留言填写表单，内容如下：
{{{
<%@ page language="java" pageEncoding="UTF-8" errorPage="/WEB-INF/jsp/include/defaultException.jsp"%>
<%@include file="/WEB-INF/jsp/include/tags.jsp"%>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
	<title>Message List</title>
  </head>
  
  <body>
	
	Leave a message:<br>
	
	<form method="POST" action="./newMessage.do">
		<textarea name="content" cols="80" rows="10"></textarea>
		
		<br/>
		<input type="submit" />
	</form>
  </body>
</html>
}}}

创建java文件 example.view.action.NewMessageAction.java 用于处理添加新留言的Form表单提交，内容如下：
{{{
package example.view.action;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.guzz.GuzzContext;
import org.guzz.transaction.WriteTranSession;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import example.business.Message;

public class NewMessageAction implements Controller {
	
	private GuzzContext guzzContext ;

	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		String content = request.getParameter("content") ;
		
		WriteTranSession write = guzzContext.getTransactionManager().openRWTran(true) ;
		
		Message msg = new Message() ;
		msg.setContent(content) ;
		msg.setCreatedTime(new java.util.Date()) ;
		
		try{
			write.insert(msg) ;
		}finally{
			write.close() ;
		}
		
		return new ModelAndView("redirect:/messageList.jsp");
	}

	public GuzzContext getGuzzContext() {
		return guzzContext;
	}

	public void setGuzzContext(GuzzContext guzzContext) {
		this.guzzContext = guzzContext;
	}

}
}}}

修改/WebRoot/WEB-INF/dispatcher-servlet.xml文件，增加NewMessageAction的映射bean：
{{{	
<bean name="/newMessage.do" class="example.view.action.NewMessageAction">
	<property name="guzzContext" ref="guzzContext" />
</bean>
}}}

部署程序，启动Tomcat6，访问：http://localhost:8080/guzz/messageList.jsp ，输入留言“I am the first message. What about you?”，提交。

打开数据tb_message表，可以看到1条记录已经成功插入。

== 分页列出发表的留言 ==

我们在messageList.jsp中列出所有发表的留言，每页30条，分页显示。对于数据库简单的读操作，我们使用guzz taglib实现。新的 messageList.jsp 内容如下；
{{{
<%@ page language="java" pageEncoding="UTF-8" errorPage="/WEB-INF/jsp/include/defaultException.jsp"%>
<%@include file="/WEB-INF/jsp/include/tags.jsp"%>
<g:page business="message" var="m_messages" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>Message List</title>
  </head>
  
  <body> 
  	 
  	Leave a message:<br>
  	
  	<form method="POST" action="./newMessage.do">
  		<textarea name="content" cols="80" rows="10"></textarea>
  		
  		<br/>
  		<input type="submit" />
  	</form>
  	
  	<hr>
  	<table width="96%" border="1">
  		<tr>
  			<th>No.</th>
  			<th>Content</th>
  			<th>Date</th>
  		</tr>
  		
  		<c:forEach items="${m_messages.elements}" var="m_msg">
  		<tr>
  			<td>${m_messages.index}</td>
  			<td><g:out value="${m_msg.content}" escapeXml="false" escapeScriptCode="true" /></td>
  			<td>${m_msg.createdTime}</td>
  		</tr>
  		</c:forEach>
  	</table>
  	
  	<table width="96%" border="1">
  		<tr>
  			<c:import url="/WEB-INF/jsp/include/console_flip.jsp" />
  		</tr>
  	</table>
  	
  </body>
</html>
}}}

在这个jsp中，
{{{
<g:page business="message" var="m_messages" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />
}}} 
根据当前传入的页码查询message，并按照id desc排序。然后我们用1个c:forEach循环，打印出结果。用m_messages.index打印出当前记录从1开始的排序位置，用g:out标签打印出允许html元素但不允许script执行的正文。最后引用通用的分页文件 /WEB-INF/jsp/include/console_flip.jsp 显示分页情况。

再次访问：http://localhost:8080/guzz/messageList.jsp ，可以看到分页显示的留言列表了：

<img width="700px" src="http://guzz.googlecode.com/svn/wiki/no-wikis/messageList.png" />

= 实现读写分离（启用第2台数据库）=

如果你有多台数据库，创建mb_main数据库的从库（具体可参看[http://guzz.javaeye.com/blog/366508]）。修改guzz.xml的
{{{
<dbgroup name="default" masterDBConfigName="masterDB" />
}}}

增加从数据库配置属性slaveDBConfigName，我们设置值为slaveDB。如下：
{{{
<dbgroup name="default" masterDBConfigName="masterDB" slaveDBConfigName="slaveDB" />
}}}

在messageBoard.properties文件增加slaveDB配置项的具体信息，如下：
{{{

[slaveDB]
guzz.identifer=defaultSlaveDB1
guzz.IP=localhost
guzz.maxLoad=80
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_main?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60

}}}

当然，如果你有单独的从数据库，jdbcUrl处修改为从库地址。

此时完成的 messageBoard.properties 文件内容为：
{{{
#guzz app config file.
 
#master db
[masterDB]
guzz.identifer=defaultMasterDB1
guzz.IP=localhost
guzz.maxLoad=120
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_main?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60

[slaveDB]
guzz.identifer=defaultSlaveDB1
guzz.IP=localhost
guzz.maxLoad=80
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_main?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60
 
#debug settings
[guzzDebug]
#runMode=debug/production
runMode=debug
#onError=halt/log/ignore
onError=halt
printSQL=true
printSQLParams=true
ignoreDemonThreadSQL=true
#print out how many nano-seconds a sql takes to execute.
measureTime=true
#only print out slow sqls that takes over xxx mill-seconds to execute. 0 means print out all.
onlySlowSQLInMillSeconds=0

############################### fundamental services #####################
 
}}}

至此，即完成了读写分离的配置。系统启动后，将创建两个连接池，上面留言读取的g:page将自动从slave数据库连接操作。在调用guzz持久化API时，所有选择允许延迟的读操作也将从slave连接池操作。

= 实现1个多用户留言板 =

为了实现多用户留言板，首先我们需要增加User域对象。User对象只有三个属性，用户编号、用户名和留言数。创建example.business.User.java:
{{{
package example.business;

public class User implements java.io.Serializable {
	
	private int id ;

	private String userName ;
	
	private int messageCount ;
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}

	public int getMessageCount() {
		return messageCount;
	}

	public void setMessageCount(int messageCount) {
		this.messageCount = messageCount;
	}
	
}
}}}

创建映射文件User.hbm.xml：
{{{
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="example.business.User" table="tb_user">
        <id name="id" type="int" column="id">
        	<generator class="native" />
        </id>
        <property name="userName" type="string" column="userName" />
        <property name="messageCount" type="int" column="messageCount" />
    </class>
</hibernate-mapping>
}}}

同时在Message.java、Message.hbm.xml 中增加userId属性对应User对象的id属性。新的Message.java和Message.hbm.xml为：
{{{
package example.business;

import java.util.Date;

public class Message implements java.io.Serializable {
	
	private int id ;

	private String content ;
	
	private int userId ;
	
	private Date createdTime ;
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Date getCreatedTime() {
		return createdTime;
	}

	public void setCreatedTime(Date createdTime) {
		this.createdTime = createdTime;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}
	
}
}}}

{{{
<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<hibernate-mapping>
    <class name="example.business.Message" table="tb_message">
        <id name="id" type="int" column="id">
        	<generator class="native" />
        </id>
        <property name="userId" type="int" column="userId" />
        <property name="content" type="string" column="content" />
        <property name="createdTime" type="datetime" column="createdTime" />
    </class>
</hibernate-mapping>
}}}

在mb_main数据库中增加tb_user表，并调整tb_message表：
{{{
use mb_main ;

create table tb_user(
	id int not null auto_increment primary key, 
	userName varchar(64) not null, 
	messageCount int(11)default 0
)engine=Innodb ;

alter table tb_message add column userId int(11) default 1 ;
create index idx_msg_uid on tb_message(userId) ;

insert into tb_user(userName) values('Lucy') ;
insert into tb_user(userName) values('Lily') ;
insert into tb_user(userName) values('Cathy') ;
insert into tb_user(userName) values('Polly, The Bird') ;

update tb_user set messageCount = (select count(*) from tb_message) where id = 1 ;

}}}

修改guzz.xml，增加User域对象的声明：
{{{
<business dbgroup="default" name="user" file="classpath:example/business/User.hbm.xml" />
}}}

由于是多用户留言板，因此 messageList.jsp 中我们需要增加一个参数用来区分用户。此参数定义为userId。无论是访问留言板，还是发表留言，我们都用userId标记当前留言板所属用户。修改 messageList.jsp 增加对userId参数的支持：
{{{
<%@ page language="java" pageEncoding="UTF-8" errorPage="/WEB-INF/jsp/include/defaultException.jsp"%>
<%@include file="/WEB-INF/jsp/include/tags.jsp"%>
<g:get business="user" var="m_user" limit="id=${param.userId}" />

<g:boundary>
	<g:addLimit limit="userId=${m_user.id}" />
	<g:page business="message" var="m_messages" tableCondition="${m_user.id}" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />
</g:boundary>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>${m_user.userName}'s Message List</title>
  </head>
  
  <body>  	 
  	Leave a message:<br>  	

  	<form method="POST" action="./newMessage.do">
  		<input type="hidden" name="userId" value="${m_user.id}" />
  		
  		<textarea name="content" cols="80" rows="10"></textarea>  		
  		....
}}}

在新的 messageList.jsp 中，g:page增加了1个查询条件。而在form表单提交时，增加了隐藏的userId参数。

修改 NewMessageAction.java 增加对userId参数的支持：
{{{
	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		int userId = RequestUtil.getParameterAsInt(request, "userId", 0) ;
		String content = request.getParameter("content") ;

		Message msg = new Message() ;
		msg.setContent(content) ;
		msg.setCreatedTime(new java.util.Date()) ;
		
		//close auto-commit
		WriteTranSession write = guzzContext.getTransactionManager().openRWTran(false) ;
		
		try{
			User user = (User) write.findObjectByPK(User.class, userId) ;
			user.setMessageCount(user.getMessageCount() + 1) ;
			
			msg.setUserId(userId) ;
			
			write.insert(msg) ;
			write.update(user) ;
			
			write.commit() ;
		}catch(Exception e){
			write.rollback() ;
			
			throw e ;
		}finally{
			write.close() ;
		}
		
		return new ModelAndView("redirect:/messageList.jsp", "userId", userId);
	}
}}}

因为要同时更新两张表，因此我们选择手工控制事务的提交。

重新部署并启动应用，访问：http://localhost:8080/guzz/messageList.jsp?userId=1 ，看到Lucy's Message List；访问 http://localhost:8080/guzz/messageList.jsp?userId=1 看到Lily's Message List。

多用户留言板完成。


= 使用2组数据库（启用第3、4台数据库） =

随着业务的增长我们发现mb_main数据库负载太高，需要将tb_user表挪出去，部署到另外一组数据库中。这组数据库有1台主库（第3台数据库）和1台从库（第4台数据库）。

我们给这组新数据库取名为userDB。首先，很显然需要将现有的tb_user表导出并装载到userDB数据库组中，并建好数据库主从。假设此步骤已经完成。

为了演示，我们在本机上创建 mb_user 数据库作为userDB。
{{{
create database mb_user default character set utf8 ;

create table mb_user.tb_user select * from mb_main.tb_user ;

alter table mb_user.tb_user modify column id int(11) not null auto_increment primary key ;

drop table mb_main.tb_user ;

}}}

这时我们有2组数据库：mb_main存放tb_message, mb_user存放tb_user。

为了让应用知道mb_user库的存在，修改guzz.xml的tran，增加一个userDB dbgroup：
{{{<dbgroup name="userDB" masterDBConfigName="userMasterDB" slaveDBConfigName="userSlaveDB" />}}}

修改User域对象使用userDB：
{{{<business dbgroup="userDB" name="user" file="classpath:example/business/User.hbm.xml" />}}}

修改messageBoard.properties主配置文件，增加userDB主从数据库连接池的配置信息[userMasterDB]和[userSlaveDB]:

{{{
[userMasterDB]
guzz.identifer=userMasterDB1
guzz.IP=localhost
guzz.maxLoad=120
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_user?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60

[userSlaveDB]
guzz.identifer=userSlaveDB1
guzz.IP=localhost
guzz.maxLoad=80
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_user?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60
}}}

如果你有第3、4台独立数据库，将上面的jdbcUrl改到具体的数据库地址即可。

重新部署并启动应用，这时您的应用已经开始使用4台数据库。当你发表新留言时，更新tb_user和tb_message表的操作将自动在一个分布式事务中完成。代码不需要做任何调整。

*注意：* 1. 通过create table ..select..的方式，索引将不复存在，真实环境下注意重新创建索引。2. 上面例子中的sql语句通过db.table的方式操作数据库，mysql主从复制可能会忽略这类操作的复制；如果从库没有执行，需要手工在从库执行sql。下同。


= 将留言表分切成小表 =

随着业务的进一步发展，很快留言数突破千万，tb_message查询缓慢，已经成为系统的性能瓶颈。我们决定将留言表按照用户分成多张小表。

分切的规则是：每个用户1张表，表名规则为tb_message_${userId}。

切表的详细说明文档，请参看：[TutorialShadowTable] 。

为了实现表分切，首先需要实现分切规则，创建一个新的java类 example.business.MessageShadowTableView 定义规则：
{{{
package example.business;

import org.guzz.exception.GuzzException;
import org.guzz.orm.AbstractShadowTableView;

public class MessageShadowTableView extends AbstractShadowTableView {

	public String toTableName(Object tableCondition) {
		if (tableCondition = null) { // 强制要求必须设置表分切条件，避免编程时疏忽。
			throw new GuzzException("null table conditon is not allowed.");
		}

		Integer userId = (Integer) tableCondition;

		//tb_message_${userId}
		return "tb_message_" + userId.intValue() ;
	}

}
}}}

可见，分切条件为用户编号userId。我们有4个用户，因此将tb_message分切成4张小表，分别为：tb_message_1, tb_message_2, tb_message_3, tb_message_4.
{{{
use mb_main ;

create table tb_message_1 select * from tb_message where userId = 1 ;
create table tb_message_2 select * from tb_message where userId = 2 ;
create table tb_message_3 select * from tb_message where userId = 3 ;
create table tb_message_4 select * from tb_message where userId = 4 ;

alter table tb_message_1 modify column id int(11) not null auto_increment primary key ;
alter table tb_message_2 modify column id int(11) not null auto_increment primary key ;
alter table tb_message_3 modify column id int(11) not null auto_increment primary key ;
alter table tb_message_4 modify column id int(11) not null auto_increment primary key ;

drop table tb_message ;
}}}

为了让guzz知道表分切规则，修改Message.hbm.xml映射文件，在class元素中增加属性 shadow="example.business.MessageShadowTableView" ，同时将dtd定义改成guzz的。修改后的文件为：
{{{
<?xml version="1.0"?>
<!DOCTYPE guzz-mapping PUBLIC "-//GUZZ//GUZZ MAPPING DTD//EN" "http://www.guzz.org/dtd/guzz-mapping.dtd">
<guzz-mapping>
    <class name="example.business.Message" table="tb_message" shadow="example.business.MessageShadowTableView">
        <id name="id" type="int" column="id">
        	<generator class="native" />
        </id>
        <property name="userId" type="int" column="userId" />
        <property name="content" type="string" column="content" />
        <property name="createdTime" type="datetime" column="createdTime" />
    </class>
</guzz-mapping>
}}}

这时guzz已经知道Message对象需要根据 example.business.MessageShadowTableView 进行切表。在所有操作 Message 的地方，需要传入userId作为切表条件（称作：tableCondition）。

对于留言读取的地方，修改 messageList.jsp 的g:page调用为：
{{{
<g:page business="message" var="m_messages" tableCondition="${param.userId}" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />
}}}

通过tableCondition属性传入切表条件。

修改 NewMessageAction.java的 write.insert(msg) 为 write.insert(msg, userId) 通过insert方法的第二个参数传入切表条件。

重新部署并启动应用，可以看到我们的留言板已经在4个小表中工作了。


= 分布式切表以应对超级大表 =

随着业务的更进一步发展，我们发现tb_message即使分成了小表，都存储在一台数据库中也过于庞大。在实际的应用中，可能是您的数据已经分切成了上百张表，总量非常大。现在，我们需要将这些分切后的小表，存储到不同的数据库机器中，减少单台数据库数据量过大的问题，同时也减少1台数据库上表的总个数。

为了解决这个问题，guzz提供了分布式切表功能，称作VirtualDB。详细介绍请参看：[TutorialVirtualDB]

为了演示，我们个性化的小表存储规则为：编号为1的用户，留言继续存储在default数据库组中不变（mb_main库中）；其他的存储到userDB中（mb_user库中）。当然在实际系统中，您可能不会这么切分，更可能引入第5、6、7、8甚至更多台的数据库机器。这里只是演示灵活的切分规则。

现在我们开始挪表，把tb_message_2, tb_message_3, tb_message_4从mb_main挪到mb_user中：
{{{
create table mb_user.tb_message_2 select * from mb_main.tb_message_2 ;
create table mb_user.tb_message_3 select * from mb_main.tb_message_3 ;
create table mb_user.tb_message_4 select * from mb_main.tb_message_4 ;

alter table mb_user.tb_message_2 modify column id int(11) not null auto_increment primary key ;
alter table mb_user.tb_message_3 modify column id int(11) not null auto_increment primary key ;
alter table mb_user.tb_message_4 modify column id int(11) not null auto_increment primary key ;

drop table mb_main.tb_message_2 ;
drop table mb_main.tb_message_3 ;
drop table mb_main.tb_message_4 ;
}}}

创建一个新的java类，定义VirtualDB的表分布规则：
{{{
package example.business;

import org.guzz.connection.AbstractVirtualDBView;
import org.guzz.exception.GuzzException;

public class MessageVirtualDBView extends AbstractVirtualDBView {
    
    public String getPhysicsDBGroupName(Object tableCondition) {
		if (tableCondition = null) {
			throw new GuzzException("null table conditon is not allowed.");
		}
		
		int userId = (Integer) tableCondition;
		
		if(userId = 1){
			 //store lucy's messages in the default database.
			return "default" ;
		}else{
			 //store others in the userDB database.
			return "userDB" ;
		}
    }

}
}}}

为了让 guzz 知道分布式切表，对于每个使用VirtualDB的领域对象，我们需要在guzz.xml中声明一个virtualdbgroup。对于Message，修改guzz.xml，在tran元素下增加virtualdbgroup：
{{{
<virtualdbgroup name="messageDB" shadow="example.business.MessageVirtualDBView" />
}}}

同时，修改Message领域对象的dbgroup到新的messageDB。修改好的guzz.xml为：
{{{
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE guzz-configs PUBLIC "-//GUZZ//DTD MAIN CONFIG//EN" "http://www.guzz.org/dtd/guzz.dtd">

<guzz-configs>
	
	<dialect class="org.guzz.dialect.Mysql5Dialect" />
	
	<tran>
		<dbgroup name="default" masterDBConfigName="masterDB" slaveDBConfigName="slaveDB" />
		<dbgroup name="userDB" masterDBConfigName="userMasterDB" slaveDBConfigName="userSlaveDB" />
		
		<virtualdbgroup name="messageDB" shadow="example.business.MessageVirtualDBView" />
	</tran>
	
	<config-server>
		<server class="org.guzz.config.LocalFileConfigServer">
			<param name="resource" value="messageBoard.properties" />
		</server>
	</config-server>
	
	<!-- business starts -->
	<business dbgroup="messageDB" name="message" file="classpath:example/business/Message.hbm.xml" />
	<business dbgroup="userDB" name="user" file="classpath:example/business/User.hbm.xml" />
	<!-- business ends -->

</guzz-configs>
}}}

重新部署并启动应用。此时的留言板将自动将lucy的留言存储到mb_main，其他人的留言存储到mb_user库中。完成分布式切表。


= 用计数器服务实现支持投票（启用第3组，第5台数据库） =
 
== 实现投票功能 ==

随着留言板应用的深入，用户希望能够对留言进行投票，像digg一样支持优秀的留言。我们需要给留言增加vote功能。Vote分为支持和反对，支持增加10分，反对减少8分。在Message中增加一个voteScore记录得票的总分数。我们给Message.java对象和对应的Message.hbm.xml文件增加3个int类型属性：
{{{
private int voteYes ;

private int voteNo ;

private int voteScore ;
}}}

调整数据库表结构，增加这3个字段：
{{{
alter table mb_main.tb_message_1 add column voteYes int(11) default 0 ;
alter table mb_main.tb_message_1 add column voteNo int(11) default 0 ;
alter table mb_main.tb_message_1 add column voteScore int(11) default 0 ;

alter table mb_user.tb_message_2 add column voteYes int(11) default 0 ;
alter table mb_user.tb_message_2 add column voteNo int(11) default 0 ;
alter table mb_user.tb_message_2 add column voteScore int(11) default 0 ;

alter table mb_user.tb_message_3 add column voteYes int(11) default 0 ;
alter table mb_user.tb_message_3 add column voteNo int(11) default 0 ;
alter table mb_user.tb_message_3 add column voteScore int(11) default 0 ;

alter table mb_user.tb_message_4 add column voteYes int(11) default 0 ;
alter table mb_user.tb_message_4 add column voteNo int(11) default 0 ;
alter table mb_user.tb_message_4 add column voteScore int(11) default 0 ;
}}}

为支持用户投票，增加一个action处理此操作，example.view.action.VoteMessageAction.java：
{{{
package example.view.action;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.guzz.Guzz;
import org.guzz.GuzzContext;
import org.guzz.transaction.WriteTranSession;
import org.guzz.util.Assert;
import org.guzz.util.RequestUtil;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import example.business.Message;

public class VoteMessageAction implements Controller {
	
	private GuzzContext guzzContext ;

	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		int userId = RequestUtil.getParameterAsInt(request, "userId", 0) ;
		int msgId = RequestUtil.getParameterAsInt(request, "msgId", 0) ;
		String type = request.getParameter("type") ;

		//auto-commit
		WriteTranSession write = guzzContext.getTransactionManager().openRWTran(true) ;
		
		try{
			//set tableCondition
			Guzz.setTableCondition(userId) ;
			Message msg = (Message) write.findObjectByPK(Message.class, msgId) ;
			Assert.assertNotNull(msg, "msg not found!") ;
			
			if("yes".equals(type)){
				msg.setVoteYes(msg.getVoteYes() + 1) ;
				msg.setVoteScore(msg.getVoteScore() + 10) ;
			}else{
				msg.setVoteNo(msg.getVoteNo() + 1) ;
				msg.setVoteScore(msg.getVoteScore() - 8) ;
			}
			
			write.update(msg) ;
		}finally{
			write.close() ;
		}
		
		return new ModelAndView("redirect:/messageList.jsp", "userId", userId);
	}

	public GuzzContext getGuzzContext() {
		return guzzContext;
	}

	public void setGuzzContext(GuzzContext guzzContext) {
		this.guzzContext = guzzContext;
	}

}
}}}

在这个Action中，我们通过 Guzz.setTableCondition(userId) 设置当前线程所有数据库操作默认的分表条件，然后获取要投票的留言，增加计数后更新。

将这个Action的配置添加到dispatcher-servlet.xml中：
{{{	
<bean name="/voteMessage.do" class="example.view.action.VoteMessageAction">
	<property name="guzzContext" ref="guzzContext" />
</bean>
}}}

修改 messageList.jsp ，列出投票数和投票地址：
{{{
<%@ page language="java" pageEncoding="UTF-8" errorPage="/WEB-INF/jsp/include/defaultException.jsp"%>
<%@include file="/WEB-INF/jsp/include/tags.jsp"%>

<g:get business="user" var="m_user" limit="id=${param.userId}" />

<g:boundary>
	<g:addLimit limit="userId=${m_user.id}" />
	<g:page business="message" var="m_messages" tableCondition="${m_user.id}" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />
</g:boundary>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>${m_user.userName}'s Message List</title>
  </head>
  
  <body>  	 
  	Leave a message:<br>
  	
  	<form method="POST" action="./newMessage.do">
  		<input type="hidden" name="userId" value="${m_user.id}" />
  		
  		<textarea name="content" cols="80" rows="10"></textarea>
  		
  		<br/>
  		<input type="submit" />
  	</form>
  	
  	<hr>
  	<table width="96%" border="1">
  		<tr>
  			<th>No.</th>
  			<th>Vote</th>
  			<th>Content</th>
  			<th>Date</th>
  		</tr>
  		
  		<c:forEach items="${m_messages.elements}" var="m_msg">
  		<tr>
  			<td>${m_messages.index}</td>
  			<td>
  				voteYes: <a href="./voteMessage.do?type=yes&userId=${m_msg.userId}&msgId=${m_msg.id}">${m_msg.voteYes}</a><br>
  				voteNo: <a href="./voteMessage.do?type=no&userId=${m_msg.userId}&msgId=${m_msg.id}">${m_msg.voteNo}</a><br>
  				voteScore: ${m_msg.voteScore}
  			</td>
  			<td>vote<g:out value="${m_msg.content}" escapeXml="false" escapeScriptCode="true" /></td>
  			<td>${m_msg.createdTime}</td>
  		</tr>
  		</c:forEach>
  	</table>
  	
  	<table width="96%" border="1">
  		<tr>
  			<c:import url="/WEB-INF/jsp/include/console_flip.jsp" />
  		</tr>
  	</table>
  	
  </body>
</html>
}}}

重新并重启应用，现在投票功能就可以使用了。

== !SlowUpdateService（使用第5台数据库） ==

虽然投票功能有了，但刚上线就发现了另外一个问题：投票的量太多。每次投票都需要进行一次数据库update操作，频繁的update操作对数据库的消耗太大。

我们希望将投票操作队列化，最好能够合并对同1条记录的多个update操作，然后用批操作的方式写入数据库，最大程度的减少数据库消耗，而不要每次都单独update。

这种场景出现的比较多，因此guzz内置了 SlowUpdateService 服务来完成这种队列化计数更新操作。详细的配置参数和工作原理，请参看：[AppendCoreService]

下面我们开始配置。为了减少对主库的影响，计数对列我们存储在第5台临时数据库中。创建数据库mb_temp，并创建计数队列存储的表tb_guzz_su：
{{{
create database mb_temp default character set utf8 ;

use mb_temp ;

create table tb_guzz_su(
	gu_id bigint not null auto_increment primary key, 
	gu_db_group varchar(32) not null, 
	gu_tab_name varchar(64) not null, 
	gu_inc_col varchar(64) not null ,
	gu_tab_pk_col varchar(64) not null,
	gu_tab_pk_val varchar(64) not null ,
	gu_inc_count int(11) not null
)engine=Innodb ;
}}}

在guzz.xml中增加mb_temp对应的数据库组tempDB，并增加临时表对应域对象的声明：
{{{
<tran>
		....
		<dbgroup name="tempDB" masterDBConfigName="tempMasterDB" />
		....
</tran>

<business dbgroup="tempDB" name="guzzSlowUpdate" file="classpath:example/business/IncUpdateBusiness.hbm.xml" />
}}}

将工程src中的 fms/business/IncUpdateBusiness.hbm.xml 挪到 example/business/ 下。fms/business目录可以删掉了。

默认的 SlowUpdateService 服务为guzz内置服务。guzz在启动时会自动创建此服务，名称为guzzSlowUpdate，配置组的名称也为guzzSlowUpdate。修改messageBoard.properties主配置文件，增加此服务配置信息，同时增加tempDB数据库组主数据库的连接池配置：
{{{
[tempMasterDB]
guzz.identifer=tempMasterDB1
guzz.IP=localhost
guzz.maxLoad=120
driverClass=com.mysql.jdbc.Driver
jdbcUrl=jdbc:mysql://localhost:3306/mb_temp?useUnicode=true&amp;characterEncoding=UTF-8&amp;useServerPrepStmts=true
user=root
password=root
acquireIncrement=10
idleConnectionTestPeriod=60

[guzzSlowUpdate]
#max size of cached queue
queueSize=20480

#batch size for updating to the temporary database.
batchSize=2048
}}}

至此，计数队列的配置完成。为了方便spring使用，我们将此服务导出为spring bean，在applicationContext.xml中添加bean：
{{{
    <bean id="guzzSlowUpdateService" class="org.guzz.web.context.spring.GuzzServiceFactoryBean"> 
        <property name="serviceName" value="guzzSlowUpdate" /> 
    </bean>
}}}

修改 VoteMessageAction.java 使用计数器服务：
{{{
package example.view.action;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.guzz.service.core.SlowUpdateService;
import org.guzz.util.RequestUtil;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import example.business.Message;

public class VoteMessageAction implements Controller {
	
	private SlowUpdateService slowUpdateService ;

	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		int userId = RequestUtil.getParameterAsInt(request, "userId", 0) ;
		int msgId = RequestUtil.getParameterAsInt(request, "msgId", 0) ;
		String type = request.getParameter("type") ;

		if("yes".equals(type)){
			//public void updateCount(Class domainClass, Object tableCondition, String propToUpdate, Serializable pkValue, int countToInc) ;
			this.slowUpdateService.updateCount(Message.class, userId, "voteYes", msgId, 1) ;
			this.slowUpdateService.updateCount(Message.class, userId, "voteScore", msgId, 10) ;
		}else{
			this.slowUpdateService.updateCount(Message.class, userId, "voteNo", msgId, 1) ;
			this.slowUpdateService.updateCount(Message.class, userId, "voteScore", msgId, -8) ;
		}
		
		return new ModelAndView("redirect:/messageList.jsp", "userId", userId);
	}

	public SlowUpdateService getSlowUpdateService() {
		return slowUpdateService;
	}

	public void setSlowUpdateService(SlowUpdateService slowUpdateService) {
		this.slowUpdateService = slowUpdateService;
	}

}
}}}

在新的Action中，不在直接操作数据库，而是调用updateCount将计数操作写入队列。

修改 dispatcher-servlet.xml ，在bean：/voteMessage.do 中注入guzzSlowUpdateService：
{{{
<bean name="/voteMessage.do" class="example.view.action.VoteMessageAction">
	<property name="slowUpdateService" ref="guzzSlowUpdateService" />
</bean>
}}}

重新部署并启动应用。投票。此时票数没有变化，没有关系，打开mb_temp数据库的tb_guzz_su表，可以看到计数操作已经成功写入到了队列中。

== !SlowUpdateServerService ==

为了将计数队列的数据写回各个表对应的主库，还需要启动计数队列服务的服务器端。修改guzz.xml文件，添加服务器端服务：
{{{
<service name="slowUpdateServer" configName="guzzSlowUpdateServer" class="org.guzz.service.db.impl.SlowUpdateServerImpl" />
}}}

修改messageBoard.properties文件，添加slowUpdateServer服务的详细配置信息：
{{{
[guzzSlowUpdateServer]
#batch size for updating the main database
batchSize=50

#page size for reading from the temporary table
pageSize=40

#how many pages to read from the temporary table for one loop updating
combinePageCount=10

#millseconds to wait for the next round of updates checking
updateInterval=500
}}}

重新部署并启动应用。查看tb_guzz_su表，队列已经被处理，访问：http://localhost:8080/guzz/messageList.jsp?userId=1 ，看到计数已经正确更新了。


= 删除留言，批量删除留言 =

== 单条留言删除 ==

创建删除留言的Action：example.view.action.DeleteMessageAction.java：
{{{
package example.view.action;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.guzz.Guzz;
import org.guzz.GuzzContext;
import org.guzz.service.core.SlowUpdateService;
import org.guzz.transaction.WriteTranSession;
import org.guzz.util.RequestUtil;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import example.business.Message;
import example.business.User;

public class DeleteMessageAction implements Controller {
	
	private GuzzContext guzzContext ;
	
	private SlowUpdateService slowUpdateService ;

	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		int userId = RequestUtil.getParameterAsInt(request, "userId", 0) ;
		int msgId = RequestUtil.getParameterAsInt(request, "msgId", 0) ;
		
		//auto-commit
		WriteTranSession write = guzzContext.getTransactionManager().openRWTran(true) ;
		
		try{
			Guzz.setTableCondition(userId) ;
			Message msg = (Message) write.findObjectByPK(Message.class, msgId) ;
			
			if(msg != null){
				write.delete(msg) ;
				
				//dec the message count
				this.slowUpdateService.updateCount(User.class, null, "messageCount", userId, -1) ;
			}
		}finally{
			write.close() ;
		}
		
		return new ModelAndView("redirect:/messageList.jsp", "userId", userId);
	}

	public GuzzContext getGuzzContext() {
		return guzzContext;
	}

	public void setGuzzContext(GuzzContext guzzContext) {
		this.guzzContext = guzzContext;
	}

	public SlowUpdateService getSlowUpdateService() {
		return slowUpdateService;
	}

	public void setSlowUpdateService(SlowUpdateService slowUpdateService) {
		this.slowUpdateService = slowUpdateService;
	}

}
}}}

配置到 dispatcher-servlet.xml 中：
{{{
<bean name="/deleteMessage.do" class="example.view.action.DeleteMessageAction">
	<property name="guzzContext" ref="guzzContext" />
	<property name="slowUpdateService" ref="guzzSlowUpdateService" />
</bean>
}}}

修改 messageList.jsp，增加delete链接到 ./deleteMessage.do?userId=${m_msg.userId}&msgId=${m_msg.id} 即可删除消息。在消息删除时，我们同时用slowUpdateService减少用户的留言数。

== 批量删除 ==

我们在 messageList.jsp 中增加一个Form表单，提交表单时提交所有选择的留言编号，服务器端根据编号批量删除。messageList.jsp:
{{{
<%@ page language="java" pageEncoding="UTF-8"%>
<%@include file="/WEB-INF/jsp/include/tags.jsp"%>

<g:get business="user" var="m_user" limit="id=${param.userId}" />

<g:boundary>
	<g:addLimit limit="userId=${m_user.id}" />
	<g:page business="message" var="m_messages" tableCondition="${m_user.id}" pageNo="${param.pageNo}" pageSize="30" orderBy="id desc" scope="request" />
</g:boundary>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>    
    <title>${m_user.userName}'s Message List</title>
  </head>
  
  <body>  	  
  	Leave a message:<br>
  	
  	<form method="POST" action="./newMessage.do">
  		<input type="hidden" name="userId" value="${m_user.id}" />
  		
  		<textarea name="content" cols="80" rows="10"></textarea>
  		
  		<br/>
  		<input type="submit" />
  	</form>
  	
  	<hr>
  	<form method="POST" action="./deleteMessage.do">
  		<input type="hidden" name="userId" value="${m_user.id}" />
  		
	  	<table width="96%" border="1">
	  		<tr>
	  			<th>No.</th>
	  			<th>Vote</th>
	  			<th>Content</th>
	  			<th>Date</th>
	  			<th>OP</th>
	  		</tr>
	  		
	  		<c:forEach items="${m_messages.elements}" var="m_msg">
	  		<tr>
	  			<td><input type="checkbox" name="ids" value="${m_msg.id}" />${m_messages.index}</td>
	  			<td>
	  				voteYes: <a href="./voteMessage.do?type=yes&userId=${m_msg.userId}&msgId=${m_msg.id}">${m_msg.voteYes}</a><br>
	  				voteNo: <a href="./voteMessage.do?type=no&userId=${m_msg.userId}&msgId=${m_msg.id}">${m_msg.voteNo}</a><br>
	  				voteScore: ${m_msg.voteScore}
	  			</td>
	  			<td>vote<g:out value="${m_msg.content}" escapeXml="false" escapeScriptCode="true" /></td>
	  			<td>${m_msg.createdTime}</td>
	  			<td><a href="./deleteMessage.do?userId=${m_msg.userId}&msgId=${m_msg.id}">Delete</a></td>
	  		</tr>
	  		</c:forEach>
	  	</table>	  	
	  	<table width="96%" border="1">
	  		<tr>
	  			<c:import url="/WEB-INF/jsp/include/console_flip.jsp" />
	  		</tr>
	  	</table>
	  	
	  	<table width="96%" border="1">
	  		<tr>
	  			<td><input type="submit" value="Delete All Selected Messages" /></td>
	  		</tr>
	  	</table>	
  	</form>
  	
  </body>
</html>
}}}

批量删除我们依然提交到 deleteMessage.do 中，只是采用POST方法提交。修改 DeleteMessageAction.java 以支持批量操作：
{{{
package example.view.action;

import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.guzz.Guzz;
import org.guzz.GuzzContext;
import org.guzz.jdbc.ObjectBatcher;
import org.guzz.orm.se.SearchExpression;
import org.guzz.orm.se.Terms;
import org.guzz.service.core.SlowUpdateService;
import org.guzz.transaction.ReadonlyTranSession;
import org.guzz.transaction.WriteTranSession;
import org.guzz.util.RequestUtil;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import example.business.Message;
import example.business.User;

public class DeleteMessageAction implements Controller {
	
	private GuzzContext guzzContext ;
	
	private SlowUpdateService slowUpdateService ;

	public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
		int userId = RequestUtil.getParameterAsInt(request, "userId", 0) ;
		
		if("POST".equals(request.getMethod())){//Batch delete
			int[] ids = RequestUtil.getParameterAsIntArray(request, "ids", 0) ;
			
			if(ids.length = 0){
				return new ModelAndView("redirect:/messageList.jsp", "userId", userId);
			}

			List<Message> msgs = null ;
			
			//load the Messages to delete.
			SearchExpression se = SearchExpression.forLoadAll(Message.class) ;
			se.setTableCondition(userId) ;
			se.and(Terms.in("id", ids)) ;
			
			//read from slave db.
			ReadonlyTranSession read = guzzContext.getTransactionManager().openDelayReadTran() ;
			try{
				msgs = read.list(se) ;
			}finally{
				read.close() ;
			}
			
			//Open write connections to the master db.
			WriteTranSession write = guzzContext.getTransactionManager().openRWTran(false) ;
			try{
				//Perform Batch operation.
				ObjectBatcher batcher = write.createObjectBatcher() ;
				batcher.setTableCondition(userId) ;
			
				for(Message msg : msgs){
					batcher.delete(msg) ;					
				}
				
				batcher.executeUpdate() ;
				
				write.commit() ;
			}catch(Exception e){
				write.rollback() ;
				
				throw e ;
			}finally{
				write.close() ;
			}
			
			//dec the message count
			this.slowUpdateService.updateCount(User.class, null, "messageCount", userId, -msgs.size()) ;
		}else{
			//Delete one message
			int msgId = RequestUtil.getParameterAsInt(request, "msgId", 0) ;
			
			//auto-commit
			WriteTranSession write = guzzContext.getTransactionManager().openRWTran(true) ;
			
			try{
				Guzz.setTableCondition(userId) ;
				Message msg = (Message) write.findObjectByPK(Message.class, msgId) ;
				
				if(msg != null){
					write.delete(msg) ;
					
					//dec the message count
					this.slowUpdateService.updateCount(User.class, null, "messageCount", userId, -1) ;
				}
			}finally{
				write.close() ;
			}
		}
		
		return new ModelAndView("redirect:/messageList.jsp", "userId", userId);
	}

	public GuzzContext getGuzzContext() {
		return guzzContext;
	}

	public void setGuzzContext(GuzzContext guzzContext) {
		this.guzzContext = guzzContext;
	}

	public SlowUpdateService getSlowUpdateService() {
		return slowUpdateService;
	}

	public void setSlowUpdateService(SlowUpdateService slowUpdateService) {
		this.slowUpdateService = slowUpdateService;
	}

}
}}}

对于POST提交的批量操作，我们获取所有提交的消息编号数组，通过 SearchExpression 查询符合的留言，创建批操作一次删除。guzz提供了两种批操作API，一种为基于对象化操作的 ObjectBatcher ，一种为基于直接SQL语句的SQLBatcher。本例子使用的是 ObjectBatcher 。

= 附录与代码 =

最终完成的工程代码：[http://guzz.googlecode.com/svn/wiki/no-wikis/MessageBoard.zip]（大小：31K）

工程代码中不包含/WebRoot/WEB-INF/lib/下所依赖的jar包。